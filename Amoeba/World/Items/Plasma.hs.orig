module World.Items.Plasma where

import Prelude hiding (Bounded)

import World.World
import World.Player
import World.Geometry
import World.Stochastic
import World.Constants
import World.Types
import World.Id

import System.Random
import qualified Data.List as L
import qualified Data.Either as E

data Plasma = Plasma { plasmaId :: ItemId
                     , plasmaPlayer :: Player }
            | ConflictedPlasma { plasmaId :: ItemId
                               , conflictedOwner :: Player
                               , conflictedPlayers :: Players }
  deriving (Show, Read)

instance Id Plasma where
  getId = plasmaId

instance Active Plasma where
<<<<<<< HEAD
  activate = inactive
=======
  activate w p _ = inactive w p
>>>>>>> 5a5bf0e9d5641b9d1d94508f81abd6718683f8ef
  ownedBy p@(Plasma{}) = plasmaPlayer p
  ownedBy p@(ConflictedPlasma{}) = conflictedOwner p

instance Descripted Plasma where
    description = show

<<<<<<< HEAD
plasma :: Point -> ItemId -> Player -> [(Point, Plasma)]
plasma p pId pl = [(p, Plasma pId pl)]

conflictedPlasma :: Point -> ItemId -> Player -> Players -> [(Point, Plasma)]
conflictedPlasma p pId pl pls = [(p, ConflictedPlasma pId pl pls)]

data GrowResult = CreepOver
                | GrowImpossible
                | Grow
                | TakeConflict Players
                | AlreadyConflicted Players
  deriving (Show, Read, Eq)

checkGrow :: Player -> Bounds -> Point -> World -> GrowResult
checkGrow pl bounds toPoint w
    | not $ inBounds toPoint bounds = GrowImpossible
    | otherwise = let items = takeWorldItems toPoint w
                  in case getPlayers items of
        []    -> Grow
        players | hasObstaclePlayer players -> GrowImpossible
                | isPlayerAlone pl players -> CreepOver
                | isPlayerHere pl players -> AlreadyConflicted (pl : players)
                | otherwise -> TakeConflict (pl : players)

defaultGrowDirs = [left, up, down, right]

conflictAnnotation p pls = annotation $ showPoint p ++ " Conflict of players: " ++ show pls
addingPlasmaAnnotation p pl = annotation $ showPointAndPlayer p pl ++ " Adding plasma"
addingConflictedPlasmaAnnotation p pl = annotation $ showPointAndPlayer p pl ++ " Adding conflicted plasma"

addPlasma :: Player -> Point -> World -> (World, Annotations)
addPlasma pl toPoint w@(World wm lId g) = let
    ann = addingPlasmaAnnotation toPoint pl
    newPlasma = plasma toPoint (lId + 1) pl
    newItems = addItemsFunc newPlasma
    in (World (updateWorldMap newItems wm) (lId + 1) g, [ann])

addConflictedPlasma :: Player -> Point -> Players -> World -> (World, Annotations)
addConflictedPlasma pl toPoint pls w@(World wm lId g) = let
    anns = [ conflictAnnotation toPoint pls
           , addingPlasmaAnnotation toPoint pl
           , addingConflictedPlasmaAnnotation toPoint pl ]
    newPlasma = plasma toPoint (lId + 1) pl
    newConflictedPlasma = conflictedPlasma toPoint (lId + 2) pl pls
    newItems = addItemsFunc (newPlasma ++ newConflictedPlasma)
    in (World (updateWorldMap newItems wm) (lId + 2) g, anns)

tryGrow :: Player -> Bounds -> (Point, Direction,  Directions)
     -> World -> Either String (World, Annotations)
tryGrow _ _ (_, _, []) _ = Left "No ways to grow"
tryGrow pl bounds (fromPoint, dir, availableDirs) w@(World wm lId g0) =
    case chooseRandomDir g0 availableDirs growProbabilities of
        Nothing -> Left "Random dir choosing failed"
        Just (g1, rndDir, restDirs) -> let toPoint = movePoint fromPoint rndDir
                                           w' = World wm lId g1
                                       in case checkGrow pl bounds toPoint w of
                Grow -> Right $ addPlasma pl toPoint w'
                CreepOver -> tryGrow pl bounds (toPoint, dir, defaultGrowDirs) w' -- Try next cell
                GrowImpossible -> tryGrow pl bounds (fromPoint, dir, restDirs) w' -- try another direction
                TakeConflict pls -> Right $ addConflictedPlasma pl toPoint pls w'
                AlreadyConflicted pls -> Left $ "Already conflicted in point " ++ show toPoint

growPlasma :: Player -> Bounds -> Point -> Direction -> World -> Either String (World, Annotations)
growPlasma pl bounds piecePoint dir = tryGrow pl bounds (piecePoint, dir, defaultGrowDirs)
=======
plasma :: Int -> Player -> Plasma
plasma = Plasma

conflictedPlasma :: ItemId -> Player -> Players -> Plasma
conflictedPlasma = ConflictedPlasma

conflictatePlasma :: Plasma -> Players -> Plasma
conflictatePlasma (ConflictedPlasma plId owner ps1) ps2 = 
    ConflictedPlasma plId owner (ps1 `L.union` ps2)
conflictatePlasma (Plasma plId pl) ps =
    ConflictedPlasma plId conflictPlayer ([pl] `L.union` ps)
  

plasmaConstructor :: Player -> ItemId -> ActiveItem
plasmaConstructor pl pId = packItem $ plasma pId pl

conflictedPlasmaConstructor :: Players -> ItemId -> ActiveItem
conflictedPlasmaConstructor pls pId = packItem $ conflictedPlasma pId conflictPlayer pls

data GrowMode = GrowOver Point
              | StopGrow

grow' :: Bound
     -> Player
     -> Actions
     -> World
     -> Point
     -> Direction
     -> Either GrowMode Actions
grow' bound pl acts w toPoint dir
    | not $ inBounds toPoint bound = Left StopGrow
    | otherwise = case takeWorldItems toPoint w of
        items | isOnePlayerHere pl items || isNonePlayersHere pl items -> Left (GrowOver toPoint)
              | isObstacleItem items -> Left StopGrow
              | otherwise -> let -- Enemies are here!
                                 pls = L.union (getPlayers items) [pl]
                                 conflAct = addSingleConflictedAction toPoint (conflictedPlasmaConstructor pls) pls
                                 act = addSingleActiveAction toPoint (plasmaConstructor pl)
                             in return (conflAct : act : acts)

grow :: Bound
     -> Player
     -> Actions
     -> StdGen
     -> World
     -> Point
     -> Direction
     -> [Direction]
     -> Either GrowMode WorldMutator
grow bound pl acts g0 w fromPoint dir triedDirs = 
    case chooseRandomDir growProbabilities g0 dir triedDirs of
        Left _ -> Left StopGrow
        Right (g1, rndDir) -> do
            let growFunc = grow' bound pl acts w (movePoint fromPoint rndDir) dir
            let nextDir = nextDirection dir
            let tryNextDirectionFunc = grow bound pl acts g1 w fromPoint nextDir (dir : triedDirs)
            let successedGrowFunc acts = Right $ createWorldMutator g1 acts
            let tryGrowMode StopGrow = tryNextDirectionFunc
            let tryGrowMode (GrowOver p) = grow bound pl acts g1 w p dir []
            E.either tryGrowMode successedGrowFunc growFunc

growPlasma :: Bound -> Player -> WorldMutator -> World -> Point -> Direction -> Either String WorldMutator
growPlasma bound pl wm@(WorldMutator acts g) w piecePoint dir = do
    let growFunc = grow bound pl acts g w piecePoint dir []
    let failGrow _ = Left "No grow possible" 
    E.either failGrow return growFunc
>>>>>>> 5a5bf0e9d5641b9d1d94508f81abd6718683f8ef
    